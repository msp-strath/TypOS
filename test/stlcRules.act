------------------------------------------------------------------------------
-- Datatypes

syntax
  { 'Type = ['EnumOrTag  ['Nat]
                         [['Arr 'Type 'Type]]
            ]
  }

syntax
  { 'Check = ['Tag [ ['Lam ['Bind 'Synth 'Check]]
                     ['Emb 'Synth]
             ]]
  ; 'Synth = ['Tag [ ['Ann 'Check 'Type]
                     ['App 'Synth 'Check]
             ]]
  }

-- this is in 'Semantics, or so we declare
syntax -- we're calling in not-'Nat on purpose
  { 'Natural = ['EnumOrTag ['Zero]
                           [['Succ 'Natural]]
               ]
  }

{-
-----------------------------------------------------------------------------
-- Judgement forms

/type : $'Type.
check : ?'Type. $'Check.
synth : $'Synth. !'Type.


-- | myCtxt maps synthesisable variables to types
myCtxt |- 'Synth -> 'Type
-}

------------------------------------------------------------------------------
-- Judgement forms and their contracts

-- Something that looks like "Z : A => B" says
-- Z is an A when it's a subject, and a B when it becomes a citizen

judgementform
  {}
  type (T : 'Type) -- no '=> B' means the citizen version is the same
  {T - 'Value : 'Semantics}

judgementform
  {type T}
  check T (t : 'Check => T - 'Value)
  { (t : _) -['Bla (T : _)]: 'Semantics
  ; (t : _) -['eq (_ : T -'Value)] : 'Bool}

judgementform
  {}
  synth (e : 'Synth => S - 'Value) S
  {type S; e -'Quote : 'Check}


-- Open question in the above: will it always be the subject that's fed to an operator?
-- Note: the "T - 'Value" is in 'Semantics and that T is the citizen, not the subject

-- {} myCtxt |- x -> T {synth x T}

rule
  {}
  type 'Nat
  {'Nat - 'Value ~> 'Natural}


rule
  {type S; type T}
  ------------------------
  type ['Arr S T] => ['Arr S T]
-- Global assumption: 'Semantics comes with Pi builtin
  {['Arr S T] - 'Value ~> ['Pi (S - 'Value) \_. (T - 'Value)]}

-- Invariant: the subject in a premise is always something with a name
-- payoff - the name BECOMES the name of the citizen

rule
  { \ x . synth x S |- check T body }
  -- x is a hypothetical inhabitant of S - 'Value
  -- hypothetical judgement with fresh x, assuming `synth x S`
  -- (note hypothetical judgements have patterns in input and subject
  --  positions, and expressions in output positions)
  check ~['Arr S T] ['Lam \x. body] => (\x. body)
  -- ~['Arr S T] means to not match, but to constrain instead
  {}
-- Could equivalently be written without deliberate capture of x:
--  { \ y . synth y S |- check T {x=y}body }
       -- note that if we use the above, then we'd expect to capture a y in S - 'Value in body the citizen
       -- the elaborator-check that body is used fully generally in the premiss subject
       -- needs to return the variables that are in scope for body the citizen

rule
  { synth e S
  ; S = T -- by the magic of STLC, things are first-order, this is just unification
  }
  check T ['Emb e] => e
  {}

-- first arg is a (subject) pattern position
-- 2nd argument is in output position & we give the citizen T
--   Note to selves: holy readability issues!

rule
  { type T
  ; check T t
  }
  synth (['Ann t T] => t) T
  {}

rule
  { synth f ~['Arr S T]
  ; check S s
  }
  synth (['App f s] => (f -['app s])) T     -- assuming citizen 'f' is meta-level function
  -- irrefutable because of no overloading of application (in STLC)
  {}

------------------------------------------------------------------------------


------------------------------------------------------------------------------
-- Examples
{-
exec check@p. p! ['Arr 'Nat ['Arr 'Nat 'Nat]].
              p! ['Lam \z. ['Lam \_. ['Emb z]]].
exec check@p. p! ['Arr 'Nat 'Nat].
              p! ['Lam \z. ['Emb z]].


exec check@p.
   p! ['Arr 'Nat 'Nat].
   p! ['Lam \z. ['Emb
         ['App ['Ann ['Lam \w. ['Emb w]] ['Arr 'Nat 'Nat]]
         ['Emb z]]]].
   PRINTF "Victory!".
-}
