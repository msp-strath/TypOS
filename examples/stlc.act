
------------------------------------------------------------------------------
-- Interface

syntax
  { 'Type = ['EnumOrTag  ['Nat]
                         [['Arr 'Type 'Type]]
            ]
  }

/type : $'Type.

syntax
  { 'Check = ['Tag [ ['Lam ['Bind 'Synth 'Check]]
                     ['Emb 'Synth]
             ]]
  ; 'Synth = ['Tag [ ['Ann 'Check 'Type]
                     ['App 'Synth 'Check]
             ]]
  }

check : ?'Type. $'Check.
synth : $'Synth. !'Type.
myCtxt |- 'Synth -> 'Type -- myCtxt maps synthesisable variables to types

------------------------------------------------------------------------------
-- Implementation

type@p = p?ty. case ty
  { 'Nat ->
  ; ['Arr S T] ->
      ( type@q. q!S.
      | type@r. r!T.
      )
  }

check@p = p?ty. p?tm. case tm
  { ['Lam \x. body] ->
      'Type?S T.
      ( ty ~ ['Arr S T]
      | \y.
        myCtxt |- y -> S .
        check@q. q!T. q!{x=y}body.)
  ; ['Emb e] -> synth@q. q!e. q?S. S ~ ty
  }

synth@p = p?tm . case (lookup myCtxt tm)
  { ['Just S] -> p!S.
  ; 'Nothing -> case tm
    { ['Ann t ty] ->
         ( type@q. q!ty.
         | check@r. r!ty. r!t.
         | p!ty.
         )
    ; ['App f s] -> 'Type?U V. p!V.
         ( synth@q. q!f. q?ty. ty ~ ['Arr U V]
         | check@r. r!U. r!s.
         )
    }
  }

------------------------------------------------------------------------------
-- Examples
{-
exec check@p. p! ['Arr 'Nat ['Arr 'Nat 'Nat]].
              p! ['Lam \z. ['Lam \_. ['Emb z]]].
-}
{-
exec check@p. p! ['Arr 'Nat 'Nat].
              p! ['Lam \z. ['Emb z]].

-}

exec check@p.
   p! ['Arr 'Nat 'Nat].
   p! ['Lam \z. ['Emb
         ['App ['Ann ['Lam \w. ['Emb w]] ['Arr 'Nat 'Nat]]
         ['Emb z]]]].
   PRINTF "Victory!".
